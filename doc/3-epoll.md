# Linux IO 模型
## IO 操作的流程
只有系统内核才能直接操作 IO，用户进程则是通过系统调用来操作 IO 的。

```text
+----------------------------------------------+
|                                              |
|                                              |
|  +-----------+   wait   +-----------------+  |  copy   +---------+
|  |           +---------->                 +------------>         |
|  | IO Device |    1     | Kernel's buffer |  |   2     | Process |
|  |           <----------+                 <------------+         |
|  +-----------+          +-----------------+  |         +---------+
|                                              |
|                                              |
+----------------------------------------------+
```

从上图看出，用户进程处理 IO 操作有两个等待时间：

1. 等待数据从设备中返回
2. 等待数据拷贝到用户空间

其中阶段1往往比阶段2耗时更多，从这个流程出发，可以总结出5种 IO 模型。

### 阻塞式 IO
最简单的 IO 方式，阻塞进程直到数据被拷贝到用户进程，耗时最久。

### 非阻塞式 IO
定期轮询 buffer 是否有数据，如有数据则等待数据拷贝到用户进程。

减少了阶段1的耗时，可以利用这个空档去做其他事情。

### IO 多路复用方式
在一些有多个 IO 点的场景，类似于非阻塞式 IO，可以在一段时间内对这些文件描述符进行轮询，然后统一返回就绪的文件描述符，这种方式称为 IO 多路复用技术。

一般说的 IO 多路复用方式指的是，select、poll 和 epoll三种方式。

其中 select 是最简单的方式，维护了文件描述符列表。poll 在 select 的基础上使用更为优化的数据结构来保存文件描述符。epoll 则使用事件的方式来避免文件描述符频繁拷贝到内核态中。

### 信号驱动 IO
处理 SIGIO 信号，当缓冲区有数据后内核发起 SIGIO 信号，再从缓冲区中拷贝到用户进程。

### 异步 IO
异步 IO 使用独立的一套 API，用户进程使用读取操作时需要指定缓冲区，内核会将 IO 设备收到的数据从内核缓冲区拷贝到用户进程缓冲区后发出特殊信号（可定制）或通过回调通知用户进程。
